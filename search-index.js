var N=null,E="",T="t",U="u",searchIndex={};
var R=["result","error","regex","Shows the original regular expression.","formatter","captures","option","splitn","usize","match","capturelocations"];

searchIndex["recap"]={"doc":"Recap deserializes structures from regex named capture…","i":[[3,"Regex","recap","A compiled regular expression for matching Unicode strings.",N,N],[5,"from_captures",E,"Deserialize a type from named regex capture groups",N,[[[R[2]],["str"]],[[R[1]],[R[0],[R[1]]]]]],[6,"Error",E,"A type which encapsulates recap errors",N,N],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"to_owned",E,E,0,[[["self"]],[T]]],[11,"clone_into",E,E,0,[[["self"],[T]]]],[11,"to_string",E,E,0,[[["self"]],["string"]]],[11,"try_from",E,E,0,[[[U]],[R[0]]]],[11,"try_into",E,E,0,[[],[R[0]]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,"borrow_mut",E,E,0,[[["self"]],[T]]],[11,"type_id",E,E,0,[[["self"]],["typeid"]]],[11,"clone",E,E,0,[[["self"]],[R[2]]]],[11,"fmt",E,R[3],0,[[[R[4]],["self"]],[[R[1]],[R[0],[R[1]]]]]],[11,"from_str",E,"Attempts to parse a string into a regular expression",0,[[["str"]],[[R[1]],[R[0],[R[2],R[1]]],[R[2]]]]],[11,"fmt",E,R[3],0,[[[R[4]],["self"]],[[R[1]],[R[0],[R[1]]]]]],[11,"new",E,"Compiles a regular expression. Once compiled, it can be…",0,[[["str"]],[[R[1]],[R[0],[R[2],R[1]]],[R[2]]]]],[11,"is_match",E,"Returns true if and only if the regex matches the string…",0,[[["str"],["self"]],["bool"]]],[11,"find",E,"Returns the start and end byte range of the leftmost-first…",0,[[["str"],["self"]],[[R[6],[R[9]]],[R[9]]]]],[11,"find_iter",E,"Returns an iterator for each successive non-overlapping…",0,[[["str"],["self"]],["matches"]]],[11,R[5],E,"Returns the capture groups corresponding to the…",0,[[["str"],["self"]],[[R[5]],[R[6],[R[5]]]]]],[11,"captures_iter",E,"Returns an iterator over all the non-overlapping capture…",0,[[["str"],["self"]],["capturematches"]]],[11,"split",E,"Returns an iterator of substrings of `text` delimited by a…",0,[[["str"],["self"]],["split"]]],[11,R[7],E,"Returns an iterator of at most `limit` substrings of…",0,[[["str"],["self"],[R[8]]],[R[7]]]],[11,"replace",E,"Replaces the leftmost-first match with the replacement…",0,[[["str"],["self"],["r"]],[["str"],["cow",["str"]]]]],[11,"replace_all",E,"Replaces all non-overlapping matches in `text` with the…",0,[[["str"],["self"],["r"]],[["str"],["cow",["str"]]]]],[11,"replacen",E,"Replaces at most `limit` non-overlapping matches in `text`…",0,[[[R[8]],["str"],["self"],["r"]],[["str"],["cow",["str"]]]]],[11,"shortest_match",E,"Returns the end location of a match in the text given.",0,[[["str"],["self"]],[[R[6],[R[8]]],[R[8]]]]],[11,"shortest_match_at",E,"Returns the same as shortest_match, but starts the search…",0,[[["str"],["self"],[R[8]]],[[R[6],[R[8]]],[R[8]]]]],[11,"is_match_at",E,"Returns the same as is_match, but starts the search at the…",0,[[["str"],["self"],[R[8]]],["bool"]]],[11,"find_at",E,"Returns the same as find, but starts the search at the…",0,[[["str"],["self"],[R[8]]],[[R[6],[R[9]]],[R[9]]]]],[11,"captures_read",E,"This is like `captures`, but uses `CaptureLocations`…",0,[[["str"],["self"],[R[10]]],[[R[6],[R[9]]],[R[9]]]]],[11,"captures_read_at",E,"Returns the same as captures, but starts the search at the…",0,[[[R[8]],["str"],["self"],[R[10]]],[[R[6],[R[9]]],[R[9]]]]],[11,"as_str",E,"Returns the original string of this regex.",0,[[["self"]],["str"]]],[11,"capture_names",E,"Returns an iterator over the capture names.",0,[[["self"]],["capturenames"]]],[11,"captures_len",E,"Returns the number of captures.",0,[[["self"]],[R[8]]]],[11,"capture_locations",E,"Returns an empty set of capture locations that can be…",0,[[["self"]],[R[10]]]]],"p":[[3,"Regex"]]};
searchIndex["recap_derive"]={"doc":E,"i":[[24,"Recap","recap_derive",E,N,N]],"p":[]};
initSearch(searchIndex);addSearchOptions(searchIndex);